import boto3
import json
import logging
import os

from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError

# DO NOT EDIT THIS FILE
# It was created by CloudFormation
# To make changes, update the CloudFormation Template

client = boto3.client('sts')
AWS_ACCOUNT_ID = client.get_caller_identity()['Account']

# HOW THIS FUNCTION WORKS
# A Metric Name is defined below as the variable METRIC_NAME
# EC2 instance details are passed to this function
# If that instance has a tag IDENTICAL to the METRIC_NAME specified
# This function will generate the necessary CloudWatch Alarm
# And send a slack notification that the alarm was created

# Variables to Modify for this Alarm
BRAND = "<account/brand name>"
METRIC_NAME = "procstat_lookup_pid_count_nginx"
METRIC_DESCRIPTION = "Nginx is above threshold"
SLACK_URL = "<slack webhook>"
SLACK_CHANNEL = "<slack channel name>"
OK_ACTIONS="arn:aws:sns:us-east-1:" + AWS_ACCOUNT_ID + ":CloudWatch-Ec2-OK"
ALARM_ACTIONS="arn:aws:sns:us-east-1:" + AWS_ACCOUNT_ID + ":CloudWatch-Ec2-InAlarm"

# You should NOT have to change anything below this line
# -------------------------------------------------------

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Create CloudWatch client
cloudwatch = boto3.client('cloudwatch')

def lambda_handler(event, context):

    instanceId = event["instanceId"]
    tags = event["tags"]
    imageId = event["imageId"]
    instanceType = event["instanceType"]
    instanceName = event["name"]

    # Set Environment Variable
    environment = getEnvironment(tags)
    logger.info("Env: " + environment)

    # Set Theshold Variable
    alarmThreshold = getThreshold(tags)

    if alarmThreshold is None:
        logger.info("No threshold set for this alarm. Aborting")
        return

    # Generate name for Alarm
    nameOfAlarm = instanceId + "_" + METRIC_NAME

    # Get all CloudWatch Alarms
    cloudWatchAlarms = cloudwatch.describe_alarms()

    # Filter for alarms that have desired metric
    hasMetric = [x for x in cloudWatchAlarms["MetricAlarms"] if x["MetricName"] == "procstat_lookup_pid_count"]

    # Find specific instance with this metric

    alarmFound = ""

    for potentialAlarm in hasMetric:
        instanceIdMatch = False
        exeMatch = False
        for i in range(len(potentialAlarm["Dimensions"])):
            if potentialAlarm["Dimensions"][i]["Value"] == instanceId :
                instanceIdMatch = True
            if potentialAlarm["Dimensions"][i]["Value"] == "nginx" :
                exeMatch = True
            if instanceIdMatch is True and exeMatch is True :
                alarmFound = potentialAlarm

    # Check if Alarm already exists for this instance
    if len(alarmFound) > 0 :
        #check if alarm needs to be updated
        needsUpdate = doesAlarmNeedUptating(alarmFound, alarmThreshold)
        if needsUpdate :
            logger.info("Alarm already exists, but needs to be updated.")
            logger.info("Updating alarm....")
            createOrUpdateAlarm(nameOfAlarm, alarmThreshold, instanceId, imageId, instanceType)
            sendSlackMessage(environment, instanceId, instanceName, alarmThreshold, "Updated")
        else :
            logger.info("Aborting - Alarm already exists.")
            return
    else :
        logger.info("Creating alarm....")
        createOrUpdateAlarm(nameOfAlarm, alarmThreshold, instanceId, imageId, instanceType)
        sendSlackMessage(environment, instanceId, instanceName, alarmThreshold, "Created")

def createOrUpdateAlarm(nameOfAlarm, alarmThreshold, instanceId, imageId, instanceType) :
    # Create or Update alarm
    # put_metric_alarm does both create and update functions
    cloudwatch.put_metric_alarm(
        AlarmName= nameOfAlarm,
        ComparisonOperator='GreaterThanOrEqualToThreshold',
        EvaluationPeriods=1,
        MetricName="procstat_lookup_pid_count",
        Namespace='CWAgent',
        Period=300,
        Statistic='Average',
        Threshold=int(alarmThreshold),
        ActionsEnabled=True,
        OKActions=[
            OK_ACTIONS,
        ],
        AlarmActions=[
            ALARM_ACTIONS,
        ],
        AlarmDescription=METRIC_DESCRIPTION + " of " + str(alarmThreshold),
        Dimensions=[
            {
              'Name': 'InstanceId',
              'Value': instanceId
            },
            {
                'Name': 'exe',
                'Value': 'nginx'
            },
            {
                'Name': 'pid_finder',
                'Value': 'native'
            },

            {
                'Name': 'ImageId',
                'Value': imageId
            },
            {
                'Name': 'InstanceType',
                'Value': instanceType
            }
        ]
    )

def sendSlackMessage(environment, instanceId, instanceName, threshold, status) :
    # Format Slack message
    slack_message = {
        'channel': SLACK_CHANNEL,
        'text': ":heavy_check_mark: %s - %s  \n :heavy_check_mark: CloudWatch Alarm - %s of %s - %s \n :heavy_check_mark: %s  %s  \n" % (BRAND, environment, METRIC_DESCRIPTION, threshold, status, instanceName, instanceId)
    }

    # Send Slack Message
    logger.info("Sending Slack Notification")
    req = Request(SLACK_URL, json.dumps(slack_message).encode('utf-8'))
    try:
        response = urlopen(req)
        response.read()
        logger.info("Message posted to %s", slack_message['channel'])
    except HTTPError as e:
        logger.error("Request failed: %d %s", e.code, e.reason)
    except URLError as e:
        logger.error("Server connection failed: %s", e.reason)

def getEnvironment(tags) :
    environment = ""
    for i in range(len(tags)) :
        if 'Environment' in tags :
            environment = tags['Environment']
        elif 'environment' in tags :
            environment = tags['environment']
        elif 'env' in tags :
            environment = tags['env']
    return environment

def getThreshold(tags) :
    for i in range(len(tags)) :
        if METRIC_NAME in tags :
            threshold = tags[METRIC_NAME]
        else :
            threshold = None
    return threshold

def doesAlarmNeedUptating(alarmFound, alarmThreshold) :
    #returns true or false
    logger.info("alarmFound: " + "{:.2f}".format(float(alarmFound["Threshold"])))
    logger.info("alarmThreshold: " + "{:.2f}".format(float(alarmThreshold)))
    if "{:.2f}".format(float(alarmFound["Threshold"])) == "{:.2f}".format(float(alarmThreshold)) :
        logger.info("Does Alarm need Updating: False")
        return False
    logger.info("Does Alarm need Updating: True")
    return True
